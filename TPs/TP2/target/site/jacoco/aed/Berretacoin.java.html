<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Berretacoin.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tp2</a> &gt; <a href="index.source.html" class="el_package">aed</a> &gt; <span class="el_source">Berretacoin.java</span></div><h1>Berretacoin.java</h1><pre class="source lang-java linenums">package aed;
import aed.ext.*;

public class Berretacoin {
    UsuarioConHandle[] usuarios;                                // Array de Usuarios con Handle
    nodoTx ultimoBloque;                                        // Direcion del ultimo Bloque de Txs
    maxHeapUsuarios heapUsuarios;                               // Usuario de mayor monto actual

<span class="fc" id="L9">    public Berretacoin(int n_usuarios){</span>
<span class="fc" id="L10">        usuarios = new UsuarioConHandle[n_usuarios];                     // Creo array de Usuarios con n usuarios</span>
<span class="fc" id="L11">        heapUsuarios = new maxHeapUsuarios();</span>
        
<span class="fc bfc" id="L13" title="All 2 branches covered.">        for (int i = 0; i &lt; n_usuarios; i++) {                    // Agrego usuarios de 1 a P a la lista de usuarios</span>
<span class="fc" id="L14">            usuarios[i] = new UsuarioConHandle(i + 1, 0);   // Y los inicializo con monto = 0</span>
<span class="fc" id="L15">            heapUsuarios.insertar(usuarios[i]);                   </span>
        }

<span class="fc" id="L18">        ultimoBloque = null;                                    // No tengo Bloques creados</span>
<span class="fc" id="L19">    }</span>


    // Complejidad O(P + n_b) = O(Cantidad de usuarios + Cantidad de Txs en bloque)
    public void agregarBloque(Transaccion[] transacciones){         
<span class="fc" id="L24">        nodoTx nuevoNodo = new nodoTx(transacciones);           // Creo un nuevo Nodo con las Tx del input (O(1))</span>
<span class="fc" id="L25">        ultimoBloque = nuevoNodo;                               // Actualizo el ultimo Bloque agregado (ahora es el nuevo) (O(1))</span>

<span class="fc bfc" id="L27" title="All 2 branches covered.">        for (Transaccion tx : transacciones) {                  // Recorro todas las Tx (O(n_b))</span>
<span class="fc" id="L28">            int comprador = tx.id_comprador();                  // Asigno idComprador (O(1))</span>
<span class="fc" id="L29">            int vendedor = tx.id_vendedor();                    // Asigno idVendedor (O(1))</span>
<span class="fc" id="L30">            int monto = tx.monto();                             // Asigno monto (O(1))</span>

<span class="pc bpc" id="L32" title="1 of 2 branches missed.">            if (vendedor != 0) {</span>
<span class="fc" id="L33">                UsuarioConHandle u = usuarios[vendedor - 1];    // Busco la posicion del vendedor en el array de Usuarios (O(1))</span>
<span class="fc" id="L34">                u.setMonto(u.getMonto() + monto);               // Sumo el monto al vendedor (O(1))</span>
<span class="fc" id="L35">                heapUsuarios.actualizarHeap(u);                 // Evaluo si hay un nuevo Usuario con mayor monto (O(1))</span>
            }

<span class="fc bfc" id="L38" title="All 2 branches covered.">            if (comprador != 0) {</span>
<span class="fc" id="L39">                UsuarioConHandle u = usuarios[comprador - 1];   // Busco la posicion del comprador en el array de Usuarios (O(1))</span>
<span class="fc" id="L40">                u.setMonto(u.getMonto() - monto);               // Resto el monto al comprador (O(1))</span>
<span class="fc" id="L41">                heapUsuarios.actualizarHeap(u);                 // Evaluo si hay un nuevo Usuario con mayor monto (O(1))</span>
            }
        }
<span class="fc" id="L44">    }</span>

    // Complejidad O(1)
    public Transaccion txMayorValorUltimoBloque(){            
<span class="pc bpc" id="L48" title="2 of 4 branches missed.">        if (ultimoBloque == null || ultimoBloque.obtenerHeap().tamano() == 0) {</span>
<span class="nc" id="L49">            return null;</span>
        }  
<span class="fc" id="L51">        return ultimoBloque.obtenerHeap().devolverPrimero();    // Devuelvo el primer elemn del heap del ultimo bloque (O(1))</span>
    }

    // Complejidad O(1), obtenerTransacciones() devuelve una copia del array de Txs
    public Transaccion[] txUltimoBloque(){
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        if (ultimoBloque == null) {</span>
<span class="nc" id="L57">            return new Transaccion[0];</span>
        }
<span class="fc" id="L59">        return ultimoBloque.obtenerTransacciones();             // Devuelvo las transacciones del ultimo Bloque (en caso que no tenga, devuelve vacío)</span>
    }

    // Complejidad O(1), devuelvo una variable ya guardada
    public int maximoTenedor(){
<span class="fc" id="L64">        UsuarioConHandle maxUser = heapUsuarios.obtenerMaximo();                              // Devuelvo ID del usuario con mayor monto (O(1))</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">        return maxUser != null ? maxUser.getId() : 0;</span>
    }

    // Complejidad O(1), accedo a valores ya calculados del ultimoBloque
    public int montoMedioUltimoBloque(){
<span class="pc bpc" id="L70" title="1 of 4 branches missed.">        if (ultimoBloque == null || ultimoBloque.totalTxSinCreacion() &lt;= 0) return 0;</span>
        // Si ultimoBloque no tiene Tx o no hay mas de 1 Tx (la de creacion) devuelvo 0
<span class="fc" id="L72">        return ultimoBloque.montoTotalSinCreacion() / ultimoBloque.totalTxSinCreacion();</span>
        // Sino, devuelvo los montos / la cantidad de Tx (ambos sin la de creacion)
    }

    // Complejidad O(log P + n_b)
    public void hackearTx() {         
<span class="fc" id="L78">        Transaccion bloqueHackeado = ultimoBloque.obtenerHeap().devolverPrimero();</span>

<span class="fc" id="L80">        int compradorId = bloqueHackeado.id_comprador();    // Guardo ID de comprador (O(1))</span>
<span class="fc" id="L81">        int vendedorId = bloqueHackeado.id_vendedor();      // Guardo ID de vendedor (O(1))</span>

        // Revertir los saldos de la transacción hackeada
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (compradorId != 0) {</span>
<span class="fc" id="L85">            UsuarioConHandle comprador = usuarios[compradorId - 1];                      // Busco al comprador en la lista de Usuarios (O(1))</span>
<span class="fc" id="L86">            comprador.setMonto(comprador.getMonto() + bloqueHackeado.monto());  // Revierto monto a comprador (O(1)) </span>
<span class="fc" id="L87">            heapUsuarios.actualizarHeap(comprador);</span>
        }
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (vendedorId != 0) {</span>
<span class="fc" id="L90">            UsuarioConHandle vendedor = usuarios[vendedorId - 1];                        // Busco al comprador en la lista de Usuarios (O(1))</span>
<span class="fc" id="L91">            vendedor.setMonto(vendedor.getMonto() - bloqueHackeado.monto());    // Revierto monto a comprador (O(1))</span>
<span class="fc" id="L92">            heapUsuarios.actualizarHeap(vendedor);</span>
        }

<span class="fc" id="L95">        ultimoBloque.eliminarPrimero();</span>

        // Actualizo montos y cantidad de Txs despues de hackear
<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (bloqueHackeado.id_comprador() == 0) {</span>
<span class="fc" id="L99">            ultimoBloque.restarMontoTotal(bloqueHackeado.monto());</span>
<span class="fc" id="L100">            ultimoBloque.restarCantidadTx();</span>
<span class="fc" id="L101">        } else {</span>
<span class="fc" id="L102">            ultimoBloque.restarMontoTotalSinCreacion(bloqueHackeado.monto());</span>
<span class="fc" id="L103">            ultimoBloque.restarCantidadTxSinCreacion();</span>
        }
<span class="fc" id="L105">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>